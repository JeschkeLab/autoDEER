:py:mod:`autodeer`
==================

.. py:module:: autodeer


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 0

   gui/index.rst
   hardware/index.rst



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   DEER_analysis/index.rst
   FieldSweep/index.rst
   Logging/index.rst
   Relaxation/index.rst
   ResPro/index.rst
   TwoD_Experiment/index.rst
   _version/index.rst
   classes/index.rst
   colors/index.rst
   criteria/index.rst
   dataset/index.rst
   pulses/index.rst
   reporter/index.rst
   sequences/index.rst
   tools/index.rst
   utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   autodeer.FieldSweepAnalysis
   autodeer.ResonatorProfileAnalysis
   autodeer.Sequence
   autodeer.CarrPurcellAnalysis
   autodeer.ReptimeAnalysis
   autodeer.Sequence
   autodeer.DEERSequence
   autodeer.HahnEchoSequence
   autodeer.T2RelaxationSequence
   autodeer.FieldSweepSequence
   autodeer.ReptimeScan
   autodeer.CarrPurcellSequence
   autodeer.RefocusedEcho2DSequence
   autodeer.ResonatorProfileSequence
   autodeer.TWTProfileSequence
   autodeer.Criteria
   autodeer.TimeCriteria
   autodeer.SNRCriteria
   autodeer.DEERCriteria
   autodeer.Sequence
   autodeer.EPRAccessor
   autodeer.Reporter



Functions
~~~~~~~~~

.. autoapisummary::

   autodeer.eprload
   autodeer.build_table
   autodeer.sop
   autodeer.transpose_dict_of_list
   autodeer.transpose_list_of_dicts
   autodeer.save_file
   autodeer.autoEPRDecoder
   autodeer.gcd
   autodeer.val_in_us
   autodeer.val_in_ns
   autodeer.round_step
   autodeer.optimise_spectra_position
   autodeer.DEERanalysis
   autodeer.DEERanalysis_plot
   autodeer.DEERanalysis_plot_pub
   autodeer.IdentifyROI
   autodeer.optimise_pulses
   autodeer.plot_overlap
   autodeer.normalise_01
   autodeer.detect_ESEEM
   autodeer.plot_1Drelax
   autodeer.build_table
   autodeer.autoEPRDecoder
   autodeer.DEERanalysis
   autodeer.autoEPRDecoder
   autodeer.get_all_axes
   autodeer.get_all_fixed_param
   autodeer.create_dataset_from_sequence
   autodeer.create_dataset_from_axes
   autodeer.create_dataset_from_bruker
   autodeer.combo_figure



Attributes
~~~~~~~~~~

.. autoapisummary::

   autodeer.__version__
   autodeer.cmap
   autodeer.log
   autodeer.primary_colors


.. py:data:: __version__
   :value: '0.7'

   

.. py:function:: eprload(path, experiment = None, type = None, **kwargs)

   
   A general versions of eprload


   :Parameters:

       **path** : str
           The file path of the data that should be loaded.

       **experiment** : str, optional
           _description_, by default None

       **type** : str, optional
           _description_, by default None

   :Returns:

       xarray.Dataarray
           _description_




   :Raises:

       ValueError
           _description_

       RuntimeError
           _description_









   ..
       !! processed by numpydoc !!

.. py:function:: build_table(source, params, params_widths)


.. py:function:: sop(spins, comps)

   
   Spin Operator Matricies.

   This function is ported from EasySpin (https://easyspin.org/easyspin/documentation/sop.html) 

   References:
   +++++++++++
   [1] Stefan Stoll, Arthur Schweiger
   EasySpin, a comprehensive software package for spectral simulation and analysis in EPR
   J. Magn. Reson. 178(1), 42-55 (2006)

   [2] Stefan Stoll, R. David Britt
   General and efficient simulation of pulse EPR spectra
   Phys. Chem. Chem. Phys. 11, 6614-6625 (2009)

   :Parameters:

       **spins** : list
           A list of each spin and its spin qunatum number

       **comps** : str
           The type of spin operator matrix to create. Options are: x,y,z,+,-,e














   ..
       !! processed by numpydoc !!

.. py:function:: transpose_dict_of_list(d)

   
   Turns a dictionary of lists into a list of dictionaries.
















   ..
       !! processed by numpydoc !!

.. py:function:: transpose_list_of_dicts(d)

   
   Turns a list of dictionaries into a dictionary of lists.
















   ..
       !! processed by numpydoc !!

.. py:function:: save_file(path, str)


.. py:function:: autoEPRDecoder(dct)


.. py:function:: gcd(values)

   
   Generates the greatest common dividor on a  list of floats


   :Parameters:

       **values** : list
           _description_














   ..
       !! processed by numpydoc !!

.. py:function:: val_in_us(Param, axis=True)

   
   Returns the value or axis of a parameter in microseconds


   :Parameters:

       **Param** : autodeer.Parameter
           The parameter to be converted

   :Returns:

       float or numpy.ndarray
           ..













   ..
       !! processed by numpydoc !!

.. py:function:: val_in_ns(Param)

   
   Returns the value or axis of a parameter in nanoseconds


   :Parameters:

       **Param** : autodeer.Parameter
           The parameter to be converted

   :Returns:

       float or numpy.ndarray
           ..













   ..
       !! processed by numpydoc !!

.. py:function:: round_step(value, step)


.. py:class:: FieldSweepAnalysis(dataset)


   

   Analysis and calculation of FieldSweep Experiment. 


   :Parameters:

       **dataset** : xarray.Dataarray
           _description_














   ..
       !! processed by numpydoc !!

   .. py:method:: find_max()

      
      Calculates the maximum field



      :Returns:

          float
              Max field













      ..
          !! processed by numpydoc !!

   .. py:method:: calc_gyro(LO = None)

      
      Calculates the gyromagnetic ratio for a given frequency


      :Parameters:

          **det_frq** : float
              The detection frequency for the field sweep.

      :Returns:

          float
              The gyromagnetic ratio in G/GHz.













      ..
          !! processed by numpydoc !!

   .. py:method:: calc_noise_level(SNR_target=30)


   .. py:method:: fit(spintype='N', **kwargs)


   .. py:method:: plot(norm = True, axis = 'field', axs=None, fig=None)

      
      Generate a field sweep plot


      :Parameters:

          **norm** : bool, optional
              Nomarlisation of the plot to a maximum of 1, by default True

          **axis** : str, optional
              plot field sweep on either the "field" axis or "freq" axis

      :Returns:

          Matplotlib.Figure
              matplotlib figure













      ..
          !! processed by numpydoc !!


.. py:class:: ResonatorProfileAnalysis(dataset, f_lims=(32, 36))


   

   Analysis and calculation of resonator profiles.


   :Parameters:

       **dataset** : xr.xarray
           The dataset containing the nutations. It must have both a 'LO' axis
           and a 'pulse0_tp' axis.

       **f_lims** : tuple, optional
           The frequency limits of the resonator profile, by default (33,35)














   ..
       !! processed by numpydoc !!

   .. py:method:: process_nutations(noisedensity = None, threshold = 2, nfft = 1000)

      
      Uses a power series to extract the resonator profile.


      :Parameters:

          **noisedensity** : tuple, optional
              If not given the first trace is assumed to be so far off resonance
              that it is just noise. 

          **nfft: int, optional**
              The length of the fft to be used, zero padded if requred, default
              is 1000.

          **threshold: int, optional**
              The multiples above the noise a single must be to not be excluded,
              default is 2.

      :Returns:

          prof_data: np.ndarray
              The resonator profile, give in nutation frequency (GHz) 

          prof_frqs: np.ndarray
              The frequency axis in GHz













      ..
          !! processed by numpydoc !!

   .. py:method:: _process_fit(R_limit=0.5)


   .. py:method:: fit(f_diff_threshold=2, cores=1, multi_mode=False, fc_guess=34.05)

      
      Fit the resonator profile with a sum of lorentzians.


      :Parameters:

          **f_diff_threshold** : float, optional
              The difference between two peaks at which they will be merged into one, by default 0.03














      ..
          !! processed by numpydoc !!

   .. py:method:: plot(fieldsweep=None, axs=None, fig=None)

      
      plot. 


      :Parameters:

          **fieldsweep** : FieldSweepAnalysis, optional
              Overlays the FieldSweep if provided, by default None

          **axs** : matplotlib.Axes, optional
              Axes to plot on, by default None

          **fig** : matplotlib.Figure, optional
              Figure to plot on, by default None

      :Returns:

          Matplotlib.Figure
              matplotlib figure object













      ..
          !! processed by numpydoc !!


.. py:function:: optimise_spectra_position(resonator_profile, fieldsweep, verbosity=0)


.. py:function:: DEERanalysis(dataset, compactness=True, model=None, ROI=False, exp_type='5pDEER', verbosity=0, **kwargs)


.. py:function:: DEERanalysis_plot(fit, background, ROI=None, axs=None, fig=None, text=True)

   
   DEERanalysis_plot Generates a figure showing both the time domain and
   distance domain data along with extra important infomation such as the 
   Modulation to Noise Ratio (MNR), Region of Interest (ROI) and the 
   recommended dipolar evolution time for future experiments based upon the 
   ROI.


   :Parameters:

       **fit** : Deerlab.FitResult
           _description_

       **background** : bool
           Should the background fit be plotted.

       **ROI** : tuple, optional
           The minimum and maximum of the Region of Interest (ROI),
           by default None

   :Returns:

       Figure
           A Matplotlib Figure object of the figure. 













   ..
       !! processed by numpydoc !!

.. py:function:: DEERanalysis_plot_pub(results, ROI=None, fig=None, axs=None)

   
   Generates a vertical plot of the DEER analysis results, ready for publication.


   :Parameters:

       **results** : Deerlab.FitResult
           The results of the DEER analysis.

       **ROI** : tuple, optional
           The minimum and maximum of the Region of Interest (ROI),
           by default None

       **fig** : matplotlib.figure.Figure, optional
           The figure to plot the results on. If None, a new figure is created.

       **axs** : matplotlib.axes.Axes, optional
           The axes to plot the results on. If None, a new axes is created.














   ..
       !! processed by numpydoc !!

.. py:function:: IdentifyROI(P, r, criterion = 0.99, method = 'gauss')

   
   IdentifyROI Identifies the region of interest. Two methods are sypported

   Methods
   +++++++

   1. Gaussian fitting ("gauss"):

   2. Intergration ("int"):

   :Parameters:

       **P** : np.ndarray
           The distance distribution.

       **r** : np.ndarray
           The distance axis

       **criterion** : float, optional
           The fraction of the distance distribution that must be in the ROI, by 
           default 0.99

       **method: str, optional**
           The method used to calculate region of interest.














   ..
       !! processed by numpydoc !!

.. py:function:: optimise_pulses(Fieldsweep, pump_pulse, exc_pulse, ref_pulse=None, filter=None, verbosity=0, method='brute', nDEER=False, num_ref_pulses=2, full_output=False)

   
   Optimise the pulse positions to maximise the pump-exc overlap.


   :Parameters:

       **Fieldsweep** : ad.FieldSweepAnalysis
           The FieldSweep analysis object

       **pump_pulse** : ad.Pulse
           The pump pulse object

       **exc_pulse** : ad.Pulse
           The excitation pulse object

       **ref_pulse** : ad.Pulse, optional
           The refocusing pulse object\, by default None

       **filter** : str or number or list, optional
           The filter profile if applicable, by default None. If it is a number a filter is generated with this cutoff frequency.
           If the string 'Matched' is used a matched filter is used. If a list is used the optimisation is performed for each filter and the best is returned.

       **verbosity** : int, optional
           The verbosity, by default 0

       **method** : str, optional
           What search optimisation is used, by default 'grid'

       **nDEER** : bool, optional
           Is the sequence an nDEER sequrence, by default False. If True then the refocusing pulse is not optimised.

       **num_ref_pulses** : int, optional
           The total number of refocusing pulses, by default 2

   :Returns:

       _type_
           _description_













   ..
       !! processed by numpydoc !!

.. py:function:: plot_overlap(Fieldsweep, pump_pulse, exc_pulse, ref_pulse, filter=None, respro=None, num_ref_pulses=2, axs=None, fig=None)

   
   Plots the pump and excitation profiles as well as the fieldsweep and filter profile.


   :Parameters:

       **Fieldsweep** : ad.FieldSweepAnalysis
           The FieldSweep analysis object

       **pump_pulse** : ad.Pulse
           The pump pulse object

       **exc_pulse** : ad.Pulse
           The excitation pulse object

       **ref_pulse** : ad.Pulse, optional
           The refocusing pulse object, by default None

       **filter** : str or number, optional
           The filter profile if applicable, by default None. If it is a number a filter is generated with this cutoff frequency.
           If the string 'Matched' is used a matched filter is used.

       **respro** : ad.ResonatorProfileAnalysis, optional
           The resonator profile for fitting, by default None. The resonator profile must include the fit.

       **num_ref_pulses** : int, optional
           The total number of refocusing pulses, by default 2

       **axs** : matplotlib.axes, optional
           The axes to plot on, by default None

       **fig** : matplotlib.figure, optional
           The figure to plot on, by default None














   ..
       !! processed by numpydoc !!

.. py:function:: normalise_01(A)

   
   Normalizes the input vector A to be between 0 and 1.

   Parameters:
   A (numpy.ndarray): Input vector to be normalized.

   Returns:
   numpy.ndarray: Normalized vector between 0 and 1.















   ..
       !! processed by numpydoc !!

.. py:class:: Sequence(*, name, B, LO, reptime, averages, shots, **kwargs)


   Represents an experimental pulse sequence.


   Represents an experimental pulse sequence.


   :Parameters:

       **name** : str
           The name of this pulse sequence

       **B** : float
           The magnetic field for this sequence in Gauss.

       **LO** : float
           The central frequency of this sequence. I.e. The frequnecy at which
           a zero offset pulse is at. 

       **reptime** : float
           The shot repetition time in us.

       **averages** : int
           The number of scans to be accumulated.

       **shots** : itn
           The number of shots per point.














   ..
       !! processed by numpydoc !!

   .. py:property:: seqtable_steps


   .. py:method:: plot()


   .. py:method:: plot_pulse_exc(FieldSweep=None, ResonatorProfile=None)


   .. py:method:: addPulse(pulse)

      
      Adds a pulse to the next position in the sequence.


      :Parameters:

          **pulse** : Pulse
              The object describing the pulse.














      ..
          !! processed by numpydoc !!

   .. py:method:: _estimate_time()

      
      Calculates the estimated experiment time in seconds.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _buildPhaseCycle()


   .. py:method:: evolution(params, reduce=[])


   .. py:method:: shift_detfreq_to_zero()


   .. py:method:: isPulseFocused()

      
      Is the sequence expressed to contain only pulses and no delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: isDelayFocused()

      
      Is the sequence expressed to contain both pulses and delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: convert(*, reduce=True)

      
      Converts the current sequence to either pulse focused or delay
      focused depending on the current state


      :Parameters:

          **reduce** : bool, optional
              Reduce to the smallest number of objects, by default True














      ..
          !! processed by numpydoc !!

   .. py:method:: _convert_to_delay()


   .. py:method:: _convert_to_pulses()


   .. py:method:: _checkRect()

      
      Checks if all the pulses in the sequence are rectangular.
















      ..
          !! processed by numpydoc !!

   .. py:method:: __str__()

      
      Return str(self).
















      ..
          !! processed by numpydoc !!

   .. py:method:: copy()


   .. py:method:: _to_dict()


   .. py:method:: _to_json()


   .. py:method:: save(filename)

      
      Save the sequence to a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          None
              ..




      :Raises:

          TypeError
              If the object cannot be serialized to JSON.









      ..
          !! processed by numpydoc !!

   .. py:method:: _from_dict(dct)
      :classmethod:


   .. py:method:: _from_json(JSONstring)
      :classmethod:


   .. py:method:: load(filename)
      :classmethod:

      
      Load an object from a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          **obj** : Sequence
              The Sequence loaded from the JSON file.




      :Raises:

          FileNotFoundError
              If the file does not exist.









      ..
          !! processed by numpydoc !!


.. py:class:: CarrPurcellAnalysis(dataset, sequence = None)


   

   Analysis and calculation of Carr Purcell decay. 


   :Parameters:

       **dataset**
           _description_














   ..
       !! processed by numpydoc !!

   .. py:method:: fit(type = 'mono')

      
      Fit the experimental CP decay


      :Parameters:

          **type** : str, optional
              Either a mono or double exponential decay model, by default "mono"














      ..
          !! processed by numpydoc !!

   .. py:method:: plot(norm = True, axs=None, fig=None)

      
      Plot the carr purcell decay with fit, if avaliable.


      :Parameters:

          **norm** : bool, optional
              Normalise the fit to a maximum of 1, by default True

      :Returns:

          Figure
              The figure.













      ..
          !! processed by numpydoc !!

   .. py:method:: check_decay(level=0.05)

      
      Checks that the data has decayed to 5% in the time lenght of the dataset.


      :Parameters:

          **level** : float, optional
              The level to check the decay, by default 0.05














      ..
          !! processed by numpydoc !!

   .. py:method:: find_optimal(SNR_target, target_time, target_step, averages=None)

      
      Calculate the optimal inter pulse delay for a given total measurment
      time. 


      :Parameters:

          **SNR_target: float,**
              The Signal to Noise ratio target.

          **target_time** : float
              The target time in hours

          **target_shrt** : float
              The shot repettition time of target in seconds

          **target_step: float**
              The target step size in ns.

          **averages** : int, optional
              The total number of shots taken, by default None. If None, the
              number of shots will be calculated from the dataset.

      :Returns:

          float
              The calculated optimal time in us













      ..
          !! processed by numpydoc !!


.. py:class:: ReptimeAnalysis(dataset, sequence = None)


   

   Analysis and calculation of Reptime based saturation recovery. 


   :Parameters:

       **dataset**
           The dataset to be analyzed.

       **sequence** : Sequence, optional
           The sequence object describing the experiment. (not currently used)














   ..
       !! processed by numpydoc !!

   .. py:method:: fit(**kwargs)


   .. py:method:: plot(axs=None, fig=None)


   .. py:method:: calc_optimal_reptime(recovery=0.9)



.. py:function:: detect_ESEEM(dataset, type='deuteron', threshold=1.5)

   
   Detect if the dataset is an ESEEM experiment.


   :Parameters:

       **dataset** : xr.DataArray
           The dataset to be analyzed.

       **type** : str, optional
           The type of ESEEM experiment, either deuteron or proton, by default 'deuteron'

       **threshold** : float, optional
           The SNR threshold for detection, by default 1.5

   :Returns:

       bool
           True if ESEEM is detected, False if not.













   ..
       !! processed by numpydoc !!

.. py:data:: cmap
   :value: ['#D95B6F', '#42A399']

   

.. py:function:: plot_1Drelax(*args, fig=None, axs=None, cmap=cmap)

   
   Create a superimposed plot of relaxation data and fits.


   :Parameters:

       **args** : ad.Analysis
           The 1D relaxation data to be plotted.

       **fig** : Figure, optional
           The figure to plot to, by default None

       **axs** : Axes, optional
           The axes to plot to, by default None

       **cmap** : list, optional
           The color map to use, by default ad.cmap














   ..
       !! processed by numpydoc !!

.. py:function:: build_table(source, params, params_widths)


.. py:function:: autoEPRDecoder(dct)


.. py:class:: Sequence(*, name, B, LO, reptime, averages, shots, **kwargs)


   Represents an experimental pulse sequence.


   Represents an experimental pulse sequence.


   :Parameters:

       **name** : str
           The name of this pulse sequence

       **B** : float
           The magnetic field for this sequence in Gauss.

       **LO** : float
           The central frequency of this sequence. I.e. The frequnecy at which
           a zero offset pulse is at. 

       **reptime** : float
           The shot repetition time in us.

       **averages** : int
           The number of scans to be accumulated.

       **shots** : itn
           The number of shots per point.














   ..
       !! processed by numpydoc !!

   .. py:property:: seqtable_steps


   .. py:method:: plot()


   .. py:method:: plot_pulse_exc(FieldSweep=None, ResonatorProfile=None)


   .. py:method:: addPulse(pulse)

      
      Adds a pulse to the next position in the sequence.


      :Parameters:

          **pulse** : Pulse
              The object describing the pulse.














      ..
          !! processed by numpydoc !!

   .. py:method:: _estimate_time()

      
      Calculates the estimated experiment time in seconds.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _buildPhaseCycle()


   .. py:method:: evolution(params, reduce=[])


   .. py:method:: shift_detfreq_to_zero()


   .. py:method:: isPulseFocused()

      
      Is the sequence expressed to contain only pulses and no delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: isDelayFocused()

      
      Is the sequence expressed to contain both pulses and delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: convert(*, reduce=True)

      
      Converts the current sequence to either pulse focused or delay
      focused depending on the current state


      :Parameters:

          **reduce** : bool, optional
              Reduce to the smallest number of objects, by default True














      ..
          !! processed by numpydoc !!

   .. py:method:: _convert_to_delay()


   .. py:method:: _convert_to_pulses()


   .. py:method:: _checkRect()

      
      Checks if all the pulses in the sequence are rectangular.
















      ..
          !! processed by numpydoc !!

   .. py:method:: __str__()

      
      Return str(self).
















      ..
          !! processed by numpydoc !!

   .. py:method:: copy()


   .. py:method:: _to_dict()


   .. py:method:: _to_json()


   .. py:method:: save(filename)

      
      Save the sequence to a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          None
              ..




      :Raises:

          TypeError
              If the object cannot be serialized to JSON.









      ..
          !! processed by numpydoc !!

   .. py:method:: _from_dict(dct)
      :classmethod:


   .. py:method:: _from_json(JSONstring)
      :classmethod:


   .. py:method:: load(filename)
      :classmethod:

      
      Load an object from a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          **obj** : Sequence
              The Sequence loaded from the JSON file.




      :Raises:

          FileNotFoundError
              If the file does not exist.









      ..
          !! processed by numpydoc !!


.. py:class:: DEERSequence(*, tau1, tau2, tau3=None, tau4=None, dt, B, LO, reptime, averages, shots, ESEEM_avg=None, **kwargs)


   Bases: :py:obj:`Sequence`

   Represents a DEER/PELDOR sequence. 


   Build a DEER sequence using rectangular pulses


   :Parameters:

       **tau1** : int or float
           The first interpulse delay in us

       **tau2** : int or float
           The second interpulse delay in us

       **dt** : int or float
           The time step for DEER measurment in ns

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point

       **tau3** : int or float, optional
           The delay between the first static pump pulse in 5-pulse DEER and 
           the 1st refocusing pulse in us, by default None. If the value is 
           None then a 4-pulse sequence is created, otherwise a 5-pulse. 

       **ESEEM_avg: str**
           Selecting the ESEEM averaging required. ESEEM averaging works by 
           introducing small stepping in the first tau delay and averaging 
           across them all. Options:
           * `proton` - 8 small steps of 8ns
           * `deuteron` - 8 small steps of 16ns
           * None - default














   ..
       !! processed by numpydoc !!

   .. py:method:: add_ESEEM_avg(type=None)


   .. py:method:: three_pulse(tp=16)

      
      Build a four pulse DEER sequence.


      :Parameters:

          **tp** : float
              Length of default RectPulse in ns, by default 16ns.














      ..
          !! processed by numpydoc !!

   .. py:method:: four_pulse(tp=16, relaxation=False)

      
      Build a four pulse DEER sequence.


      :Parameters:

          **tp** : float
              Length of default RectPulse in ns, by default 16ns.














      ..
          !! processed by numpydoc !!

   .. py:method:: five_pulse(tp=16, relaxation=False, re_step=50, re_dim=100)

      
      Build a five pulse DEER sequence.


      :Parameters:

          **tp** : float
              Length of default RectPulse in ns, by default 16ns.














      ..
          !! processed by numpydoc !!

   .. py:method:: seven_pulse(tp=16, relaxation=False)

      
      Build a seven pulse DEER sequence.


      :Parameters:

          **tp** : float
              Length of default RectPulse in ns, by default 16ns.














      ..
          !! processed by numpydoc !!

   .. py:method:: nDEER_CP(n, tp=16, relaxation=False, pcyc='Normal')

      
      Generate an nDEER sequence.

      The sum of tau1 and tau2 is used as total trace length. 

      :Parameters:

          **n** : int
              The number of refocusing pulses

          **tp** : int, optional
              _description_, by default 16

          **relaxation** : bool, optional
              _description_, by default False

          **pcyc: str, optional**
              Normal: Phases cycles pump and observer pulses, no DC cycle
              NormalDC: Phases cycles pump and observer pulses, DC cycle
              Obs: Phases cycles observer pulses, no DC cycle
              ObsDC: Phases cycles and observer pulses, DC cycle














      ..
          !! processed by numpydoc !!

   .. py:method:: select_pcyc(option)

      
      Choose which DEER phase you would like.

      .. |xp| replace:: x\ :sub:`p`

      .. table::
          :width: 150
          :widths: 10 10 10 5 30 30 5

          +---------------------------+-------------+----------------+--------+---------------------------+-----------------------------+------------+
          | Phase cycle               | Short Code  | Sequence       | Steps  | Pulse Phase Cycle         | Remaining Echoes            | Ref.       |
          +===========================+=============+================+========+===========================+=============================+============+
          | (x)x|xp|x                 | DC          | ALL            | 2      | [+(+x)-(-x)]              | PE12rp, SE(PE12)p3, PE12rpr3|            |
          +---------------------------+-------------+----------------+--------+---------------------------+-----------------------------+------------+
          | (x)[|xp|]x                | 8step_3p    | 3 pulse        | 8      | [+(+x)-(-x)]              |                             |            |
          +---------------------------+-------------+----------------+--------+---------------------------+-----------------------------+------------+
          | x[x][|xp|]x               | 16step_4p   | 4 pulse        | 16     | [+(+x)-(+y)+(-x)-(-y)]    |                             | [1]        |
          +---------------------------+-------------+----------------+--------+                           +-----------------------------+------------+
          | x|xp|[x][|xp|]x           | 16step_5p   | 5 pulse        | 16     | [+(+x)+(+y)+(-x)+(-y)]    | PEp02r3,b PE1p0r2r3b        | [1]        |
          +---------------------------+-------------+----------------+--------+---------------------------+-----------------------------+------------+
          | x[x]|xp|(x)(|xp|)(|xp|)x  | 32step_7p   | 7 pulse        | 32     |                           |                             | [1]        |
          +---------------------------+-------------+----------------+--------+---------------------------+-----------------------------+------------+

      :Parameters:

          **option** : str
              The short code of the phase cycle. See table above.














      ..
          !! processed by numpydoc !!

   .. py:method:: simulate()



.. py:class:: HahnEchoSequence(*, B, LO, reptime, averages, shots, **kwargs)


   Bases: :py:obj:`Sequence`

   Represents a Hahn-Echo sequence. 


   Build a Hahn-Echo sequence using either rectangular pulses or
   specified pulses. By default no progression is added to this sequence.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point














   ..
       !! processed by numpydoc !!


.. py:class:: T2RelaxationSequence(*, B, LO, reptime, averages, shots, step=40, dim=200, **kwargs)


   Bases: :py:obj:`HahnEchoSequence`

   Represents a T2 relaxation sequence. A Hahn Echo where the interpulse delay increases


   Build a Hahn-Echo sequence using either rectangular pulses or
   specified pulses. By default no progression is added to this sequence.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point














   ..
       !! processed by numpydoc !!


.. py:class:: FieldSweepSequence(*, B, LO, Bwidth, reptime, averages, shots, **kwargs)


   Bases: :py:obj:`HahnEchoSequence`

   Represents a Field Sweep (EDFS) sequence. 


   Build a Field Sweep (EDFS) sequence using either rectangular pulses or
   specified pulses.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **Bwidth: int or float**
           The width of the field sweep, in Gauss

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point














   ..
       !! processed by numpydoc !!


.. py:class:: ReptimeScan(*, B, LO, reptime, reptime_max, averages, shots, **kwargs)


   Bases: :py:obj:`HahnEchoSequence`

   Represents a reptime scan of a Hahn Echo Sequence. 


   A Hahn echo sequence is perfomed with the shot repetition time increasing.1


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime: float**
           The default reptime, this is used for tuning pulses etc...

       **reptime_max** : np.ndarray
           The maximum shot repetition time in us    

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point














   ..
       !! processed by numpydoc !!


.. py:class:: CarrPurcellSequence(*, B, LO, reptime, averages, shots, tau, n, dim=100, **kwargs)


   Bases: :py:obj:`Sequence`

   Represents a Carr-Purcell sequence. 


   Build a Carr-Purcell dynamical decoupling sequence using either 
   rectangular pulses or specified pulses.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point

       **tau** : int
           The maximum total sequence length in us

       **n** : int
           The number refocusing pulses

       **dim** : int
           The number of points in the X axis














   ..
       !! processed by numpydoc !!

   .. py:method:: _build_sequence()



.. py:class:: RefocusedEcho2DSequence(*, B, LO, reptime, averages, shots, tau, dim=100, step=50, **kwargs)


   Bases: :py:obj:`Sequence`

   Represents a 2D Refocused-echo Sequence. 


   Build a 2D Refocused-echo sequence using either 
   rectangular pulses or specified pulses.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point

       **tau** : int
           The starting value in ns

       **dim: int**
           The number of points in both the X and Y axis

       **step: float**
           The step in ns for both the X and Y axis














   ..
       !! processed by numpydoc !!

   .. py:method:: _build_sequence()



.. py:class:: ResonatorProfileSequence(*, B, LO, reptime, averages, shots, fwidth=0.3, **kwargs)


   Bases: :py:obj:`Sequence`

   Builds nutation based Resonator Profile sequence. 


   Build a resonator profile nutation sequence using either 
   rectangular pulses or specified pulses.


   :Parameters:

       **B** : int or float
           The B0 field, in Guass

       **Bwidth: int or float**
           The width of the field sweep, in Gauss

       **LO** : int or float
           The LO frequency in GHz

       **reptime** : _type_
           The shot repetition time in us

       **averages** : int
           The number of scans.

       **shots** : int
           The number of shots per point

       **fwidth: float**
           The frequency width of the resonator profile in GHz, 
           by default 0.3GHz

       **tau1: float**
           The delay between the nutating pulse and the Hahn Echo, 
           by default 2000 ns

       **tau2: float**
           The interpulse delay in the Hahn Echo, 
           by default 500 ns














   ..
       !! processed by numpydoc !!

   .. py:method:: _build_sequence()



.. py:class:: TWTProfileSequence(*, B, LO, reptime, averages=1, shots=100, **kwargs)


   Bases: :py:obj:`Sequence`

   Builds TWT based Resonator Profile sequence. 


   Represents an experimental pulse sequence.


   :Parameters:

       **name** : str
           The name of this pulse sequence

       **B** : float
           The magnetic field for this sequence in Gauss.

       **LO** : float
           The central frequency of this sequence. I.e. The frequnecy at which
           a zero offset pulse is at. 

       **reptime** : float
           The shot repetition time in us.

       **averages** : int
           The number of scans to be accumulated.

       **shots** : itn
           The number of shots per point.














   ..
       !! processed by numpydoc !!

   .. py:method:: _build_sequence()



.. py:function:: DEERanalysis(dataset, compactness=True, model=None, ROI=False, exp_type='5pDEER', verbosity=0, **kwargs)


.. py:data:: log

   

.. py:class:: Criteria(name, test, description = '', end_signal=None)


   
   A class for defining criteria for terminating experiments. This should
   only be subclassed and not used directly.
















   ..
       !! processed by numpydoc !!
   .. py:method:: __add__(__o)



.. py:class:: TimeCriteria(name, end_time, description = '', **kwargs)


   Bases: :py:obj:`Criteria`

   A class for defining criteria for terminating experiments. This should
   only be subclassed and not used directly.


   Criteria testing for a specific finishing time. The finishing time 
   is given as absolute time in the locale of the computer, it is *not* 
   how the long the measurment continues for. 


   :Parameters:

       **name** : str
           _description_

       **end_time** : float
           Finishing time in seconds since epoch

       **description** : str, optional
           _description_, by default None














   ..
       !! processed by numpydoc !!


.. py:class:: SNRCriteria(SNR_target, description = '', verbosity=0, **kwargs)


   Bases: :py:obj:`Criteria`

   A class for defining criteria for terminating experiments. This should
   only be subclassed and not used directly.


   Criteria testing for signal to noise ratio. This checks the SNR of 
   the normalised absolute data using the deerlab SNR noise estimation
   which is based on the work by Stoher et. al. [1]


   :Parameters:

       **name** : str
           _description_

       **SNR_target** : int
           The mimimum SNR value.

       **description** : str, optional
           _description_, by default None










   .. rubric:: References

   [1] F. Stoehr, R. White, M. Smith, I. Kamp, R. Thompson, D. Durand,
   W. Freudling, D. Fraquelli, J. Haase, R. Hook, T. Kimball, M. Kummel,
   K. Levay, M. Lombardi, A. Micol, T. Rogers DERSNR: A Simple & General
   Spectroscopic Signal-to-Noise Measurement Algorithm Astronomical Data
   Analysis Software and Systems XVII, ASP Conference Series, Vol. 30,
   2008, p5.4

   .. only:: latex

      




   ..
       !! processed by numpydoc !!


.. py:class:: DEERCriteria(mode='Speed', model=None, verbosity=0, update_func=None, **kwargs)


   Bases: :py:obj:`Criteria`

   A class for defining criteria for terminating experiments. This should
   only be subclassed and not used directly.


   Criteria for running DEER experiments.


   :Parameters:

       **tau1** : _type_
           _description_

       **tau2** : _type_
           _description_

       **tau3** : _type_, optional
           _description_, by default None

       **mode** : str, optional
           _description_, by default "Speed"

   :Returns:

       _type_
           _description_













   ..
       !! processed by numpydoc !!


.. py:function:: autoEPRDecoder(dct)


.. py:class:: Sequence(*, name, B, LO, reptime, averages, shots, **kwargs)


   Represents an experimental pulse sequence.


   Represents an experimental pulse sequence.


   :Parameters:

       **name** : str
           The name of this pulse sequence

       **B** : float
           The magnetic field for this sequence in Gauss.

       **LO** : float
           The central frequency of this sequence. I.e. The frequnecy at which
           a zero offset pulse is at. 

       **reptime** : float
           The shot repetition time in us.

       **averages** : int
           The number of scans to be accumulated.

       **shots** : itn
           The number of shots per point.














   ..
       !! processed by numpydoc !!

   .. py:property:: seqtable_steps


   .. py:method:: plot()


   .. py:method:: plot_pulse_exc(FieldSweep=None, ResonatorProfile=None)


   .. py:method:: addPulse(pulse)

      
      Adds a pulse to the next position in the sequence.


      :Parameters:

          **pulse** : Pulse
              The object describing the pulse.














      ..
          !! processed by numpydoc !!

   .. py:method:: _estimate_time()

      
      Calculates the estimated experiment time in seconds.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _buildPhaseCycle()


   .. py:method:: evolution(params, reduce=[])


   .. py:method:: shift_detfreq_to_zero()


   .. py:method:: isPulseFocused()

      
      Is the sequence expressed to contain only pulses and no delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: isDelayFocused()

      
      Is the sequence expressed to contain both pulses and delays?
















      ..
          !! processed by numpydoc !!

   .. py:method:: convert(*, reduce=True)

      
      Converts the current sequence to either pulse focused or delay
      focused depending on the current state


      :Parameters:

          **reduce** : bool, optional
              Reduce to the smallest number of objects, by default True














      ..
          !! processed by numpydoc !!

   .. py:method:: _convert_to_delay()


   .. py:method:: _convert_to_pulses()


   .. py:method:: _checkRect()

      
      Checks if all the pulses in the sequence are rectangular.
















      ..
          !! processed by numpydoc !!

   .. py:method:: __str__()

      
      Return str(self).
















      ..
          !! processed by numpydoc !!

   .. py:method:: copy()


   .. py:method:: _to_dict()


   .. py:method:: _to_json()


   .. py:method:: save(filename)

      
      Save the sequence to a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          None
              ..




      :Raises:

          TypeError
              If the object cannot be serialized to JSON.









      ..
          !! processed by numpydoc !!

   .. py:method:: _from_dict(dct)
      :classmethod:


   .. py:method:: _from_json(JSONstring)
      :classmethod:


   .. py:method:: load(filename)
      :classmethod:

      
      Load an object from a JSON file.


      :Parameters:

          **filename** : str
              Path to the JSON file.

      :Returns:

          **obj** : Sequence
              The Sequence loaded from the JSON file.




      :Raises:

          FileNotFoundError
              If the file does not exist.









      ..
          !! processed by numpydoc !!


.. py:function:: get_all_axes(sequence)


.. py:function:: get_all_fixed_param(sequence)


.. py:function:: create_dataset_from_sequence(data, sequence, extra_params={})


.. py:function:: create_dataset_from_axes(data, axes, params = None, axes_labels=None)


.. py:function:: create_dataset_from_bruker(filepath)


.. py:class:: EPRAccessor(xarray_obj)


   .. py:property:: save


   .. py:property:: correctphase


   .. py:property:: normalise


   .. py:property:: correctphasefull


   .. py:property:: SNR


   .. py:property:: fft


   .. py:property:: sequence



.. py:class:: Reporter(filepath, pagesize='A4')


   .. py:method:: header(canvas, doc)


   .. py:method:: footer(canvas, doc)


   .. py:method:: _build()


   .. py:method:: add_title(key, title)


   .. py:method:: add_new_section(key, title)


   .. py:method:: add_text(key, text, title=None)


   .. py:method:: add_code_block(key, code, title=None)


   .. py:method:: add_figure(key, figure, title=None)


   .. py:method:: add_space(key, height=5)


   .. py:method:: add_page_break(key)


   .. py:method:: add_table(key, lists)

      
      Generates a table as a reportlab flowable from a list of lists
















      ..
          !! processed by numpydoc !!


.. py:function:: combo_figure(EDFS, respro, pulses, relaxation, init_deer, long_deer, title=None)

   
   Creates a 2x2 summary figure. 
       - The top left plot is the EDFS and resonator profile, overlapped with the optimised pulses. 
       - The top right plot is the relaxation data and fits.
       - The bottom left plot is the initial DEER data and fits.
       - The bottom right plot is the final DEER data and fits.


   :Parameters:

       **EDFS: ad.FieldSweepAnalysis**
           The Echo-Detected Field Sweep analysis.

       **respro: ad.ResonatorProfileAnalysis**
           The resonator profile analysis

       **pulses: dict**
           A dictionary containing the optimised pulses.

       **relaxation: list**
           A list containing the relaxation data and fits.

       **init_deer: deerlab.FitResult**
           The initial DEER data and fits.

       **long_deer: deerlab.FitResult**
           The final DEER data and fits.

       **title: str, optional**
           The title of the figure, by default None














   ..
       !! processed by numpydoc !!

.. py:data:: primary_colors
   :value: ['#D95B6F', '#42A399', 'E1AE38']

   

